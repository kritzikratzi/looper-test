package looper;

/**
 * This sketch demonstrates how to use an FFT to analyze
 * the audio being generated by an AudioPlayer.
 * <p>
 * FFT stands for Fast Fourier Transform, which is a 
 * method of analyzing audio that allows you to visualize 
 * the frequency content of a signal. You've seen 
 * visualizations like this before in music players 
 * and car stereos.
 */

import java.awt.Container;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.LinkedHashMap;

import javax.sound.sampled.AudioInputStream;

import processing.core.PApplet;
import processing.core.PGraphics;
import processing.core.PVector;
import ddf.minim.analysis.*;
import ddf.minim.javasound.JSMinim;
import ddf.minim.spi.AudioRecordingStream;
import ddf.minim.*;



public class Main extends PApplet{
	Minim       minim;
	
	JSMinim mimp; 
	AudioPlayer jingle;
	FFT         fft;
	BeatDetect beat;
	PGraphics preview; 
	private int totalSamples;
	private ArrayList<Integer> beats = new ArrayList<>();
	
	int loopStart, loopEnd;

	private float[] samples; 
	LinkedHashMap<Integer,PVector> diffs = new LinkedHashMap<>(); 
	
	String filename = "zelda.wav"; 
	
	
	public static void main(String[] args) {
		PApplet.main( new String[]{ "looper.Main" } ); 
	}
	
	
	public void setup(){
		size(1200, 200, JAVA2D );
		preview = createGraphics( width, 100 ); 
		minim = new Minim(this);
		mimp = new JSMinim( this );
		mimp.debugOn(); 
		// specify that we want the audio buffers of the AudioPlayer
		// to be 1024 samples long because our FFT needs to have 
		// a power-of-two buffer size and this is a good size.
		jingle = minim.loadFile(filename, 1024);
		// loop the file indefinitely
		jingle.loop(); 

		// create an FFT object that has a time-domain buffer 
		// the same size as jingle's sample buffer
		// note that this needs to be a power of two 
		// and that it means the size of the spectrum will be half as large.
		fft = new FFT( jingle.bufferSize(), jingle.sampleRate() );
		MultiChannelBuffer sampleBuffer = new MultiChannelBuffer(0,0); // params don't matter!
		float jingleBuffer = loadFileIntoBuffer( filename, sampleBuffer );
		totalSamples = sampleBuffer.getBufferSize();
		beat = new BeatDetect( 4096*4, jingle.sampleRate() );
		beat.setSensitivity(1);
		beat.detectMode(BeatDetect.FREQ_ENERGY);
		// find ALL beats
		float data[] = new float[2048]; 
		samples = sampleBuffer.getChannel(1);
		
//		for( int i = 0; i < samples.length; i+= data.length ){
//			int j = Math.min( samples.length-1, i + data.length - 1 ); 
////			System.out.println( "copy up to including " + ( j ) + " / " + samples.length);
//			System.arraycopy( samples, i, data, 0, 1 + j - i );
//			beat.detect( data ); 
//			if( beat.isOnset() ){
//				beats.add( i ); 
//				System.out.println( i + ": " + beat.isKick() ); 
//			}
//		}
		
		// pick some starting point ... 
		loopEnd = samples.length; 
		int start = (int) random( 3*samples.length/5 );
		analyze( start );  
		new Thread(){
			public void run(){
				try{
					while( true ){
						Thread.sleep( 1 ); 
						// figure it out
						int s = (int) (loopStart*1000l/jingle.getFormat().getSampleRate());
						int e = (int) (loopEnd*1000l/jingle.getFormat().getSampleRate());
						if( jingle.position() < s ) jingle.cue( s + 10 );
						else if( jingle.position() > e ) jingle.cue( s );
						else continue; 
						Thread.sleep( 500 ); 
					}
				}
				catch( InterruptedException e ){
					e.printStackTrace(); 
				}
			}
		}.start(); 
		
		
//		System.exit(0); 
	}

	public void draw()
	{
		background(0);
		stroke(255);

		// perform a forward FFT on the samples in jingle's mix buffer,
		// which contains the mix of both the left and right channels of the file
		fft.forward( jingle.mix );

		for(int i = 0; i < fft.specSize(); i++)
		{
			// draw the line for frequency band i, scaling it up a bit so we can see it
			line( i, height/2, i, height/2 - fft.getBand(i)*4 );
		}
		
		stroke( 255, 0, 0 ); 
		for( int beat : beats ){
			float x = beat*width/totalSamples; 
			line( x, 0, x, height ); 
		}
		
		stroke( 255, 255, 0 ); 
		float x = jingle.position()*width/jingle.length();
		line( x, 0, x, height ); 
		
		image( preview, 0, 0 ); 
		
		stroke( 0, 255, 0 ); 
		float s = (float)width/samples.length; 
		line( loopStart*s, 0, loopStart*s, height ); 
		line( loopEnd*s, 0, loopEnd*s, height ); 
	}
	
	
	public void analyze( int start ){
		diffs.clear(); 
		
		loopStart = start; 
		int SUB = 64; 
		int N = 2048*SUB; 
		float maxDiff = 0; 
		int upper = (int) min( samples.length-N, start + 30*jingle.getFormat().getSampleRate() );  
		for( int i = start + N; i < upper - N; i++ ){
			if( i % 10000 == 0 ) System.out.println(i + "/" + (upper-start) );
			float diff = 0; 
			for( int j  = 0; j < N; j+= SUB ){
				diff += Math.abs( samples[i + j] - samples[start + j] ); 
			}
			maxDiff = max( maxDiff, diff );
			diffs.put( i, new PVector( i, diff ) ); 
		}
		
		preview.beginDraw(); 
		preview.clear();
		preview.noFill(); 
		preview.stroke( 255 ); 
		preview.beginShape();
		for( int i = 0; i <= width; i++ ){
			preview.vertex( i, preview.height/2 + height/2*samples[(int) (i*(samples.length-1l)/width)] );
		}
		preview.endShape(); 
		preview.endDraw();

		preview.beginDraw(); 
		preview.clear();
		preview.stroke( 255, 0, 0 );
		preview.beginShape();
		int n = 0;  
		int prevX = 0;  
		float sum = maxDiff; 
		for( PVector diff : diffs.values() ){
			int x = (int) (diff.x*(long)width/samples.length);
			sum = min( diff.y, sum ); 
			n = 1; 
			if( x != prevX ){
				preview.vertex( x, preview.height*sum/maxDiff/n );  
				n = 0; 
				sum = maxDiff; 
				prevX = x; 
			}
		}
		preview.endShape(); 
		preview.endDraw(); 
	}
	
	
	@Override
	public void keyPressed() {
		if( key == 'r' ){
			loopEnd = (int) (mouseX*(long)samples.length/width);
		}
		if( key == 'a' ){
			PVector best = new PVector( 0, Float.MAX_VALUE );  
			int sampleNr = (int) (mouseX*(long)samples.length/width); 
			for( int i = sampleNr - 500000; i < sampleNr + 500000; i++ ){
				PVector diff = diffs.get( i ); 
				if( diff != null ){
					if( diff.y < best.y ) best = diff; 
				}
			}
			
			if( best.x != 0 ){
				loopEnd = (int) best.x; 
			}
		}
		if( keyCode == RIGHT ){
			jingle.cue( (int) (loopEnd*1000l/jingle.getFormat().getSampleRate() - 1000) ); 
		}
	}
	
	@Override
	public void mouseClicked() {
		int sampleNr = (int) (mouseX*(long)samples.length/width); 
		analyze( sampleNr ); 
	} 
	
	
	// from minim.java: 
	/**
	 * Loads the requested file into a MultiChannelBuffer. The buffer's channel count
	 * and buffer size will be adjusted to match the file.
	 * 
	 * @shortdesc Loads the requested file into a MultiChannelBuffer.
	 * 
	 * @example Advanced/loadFileIntoBuffer
	 * 
	 * @param filename 
	 * 			the file to load
	 * @param outBuffer
	 * 			the MultiChannelBuffer to fill with the file's audio samples
	 * 
	 * @return	the sample rate of audio samples in outBuffer, or 0 if the load failed.
	 * 
	 * @related MultiChannelBuffer
	 */
	public float loadFileIntoBuffer( String filename, MultiChannelBuffer outBuffer )
	{
		final int readBufferSize 		= 4096;
		float     sampleRate 			= 0;
		AudioRecordingStream  stream 	= mimp.getAudioRecordingStream( filename, readBufferSize, false );
		if ( stream != null )
		{
			stream.open();
			stream.play();
			
			sampleRate = stream.getFormat().getSampleRate();
			final int channelCount = stream.getFormat().getChannels();
			// for reading the file in, in chunks.
			MultiChannelBuffer readBuffer = new MultiChannelBuffer( channelCount, readBufferSize );
			// make sure the out buffer is the correct size and type.
			outBuffer.setChannelCount( channelCount );
			// how many samples to read total
			
			final long totalSampleCount = stream.getSampleFrameLength();
			outBuffer.setBufferSize( (int)totalSampleCount );
			

			// now read in chunks.
			long totalSamplesRead = 0;
			while( totalSamplesRead < totalSampleCount )
			{
				// is the remainder smaller than our buffer?
				if ( totalSampleCount - totalSamplesRead < readBufferSize )
				{
					readBuffer.setBufferSize( (int)(totalSampleCount - totalSamplesRead) );
				}

				stream.read( readBuffer );

				// copy data from one buffer to the other.
				for(int i = 0; i < channelCount; ++i)
				{
					// a faster way to do this would be nice.
					for(int s = 0; s < readBuffer.getBufferSize(); ++s)
					{
						outBuffer.setSample( i, (int)totalSamplesRead+s, readBuffer.getSample( i, s ) );
					}
				}

				totalSamplesRead += readBuffer.getBufferSize();
			}

			stream.close();
		}
	    else
	    {
	        debug("Unable to load an AudioRecordingStream for " + filename);
	    }

		return sampleRate;
	}
	
	
}